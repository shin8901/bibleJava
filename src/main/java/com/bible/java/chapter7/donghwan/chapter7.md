#객체지향2
# 1.상속
 - 코드의 재사용성이 높음
 - 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속
 - 상속관계? 포함관계?    [~은 ~이다(is-a)], [~은 ~을 가지고 있다(has -a)] 를 넣어 문장 만들어보기  
 - 단일 상속 -> 상속받은 멤버간의 이름이 일치할 경우 > 혼잡스러워짐을 방지
 - 자식 참조변수로 -> 부모인스턴스 만들기 불가능(참조변수가 범위가 더 많기 떄문에 허용하지 않는다)

# 2.오버라이딩
 - 상속 받은 메서드를 변경하는 것
 - 오버라이딩 조건 [이름,매개변수,리턴타입]이 같아야함.
 - 조상보다 좁은 범위의 접근제어자를 쓸수없다
 - 조상보다 더 많은 예외 불가(자식 Exception 쓰는 경우 조심) 
  
# 3. package와 import 
  - 패키지는 점(.)을 구분자로하여 계층구조를 구성할 수 있다.
  - import문은 성능에 영향을 미치지 않는다. 많아지면 컴파일시 시간이 좀 더 걸릴뿐...
 
# 4. 제어자
  - 접근 제어자 [public, protected, default, private]
  - 그외 [static, final, abstract, native, trabsuebtm synchronized, volatile, strictfp]
  - final [클래스, 메서드, 변수]
  - "캡슐화" -> 감춰야한다 -> 굳이 알필요도 없다
  - 하나의 소스파일(*.java)에는 public클래스가 단 하나만 존재할 수 있다. 파일이름은 같아야한다
  - default, protected  에러나는 이유??
  - transient https://nesoy.github.io/articles/2018-06/Java-transient

# 5. 다형성
  - 여러 가지 형태를 가질 수 있는 능력 [조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조]
  - instanceof 연산은 상속받은 타입까지 허용 -> 타입으로 변경 가능
 
# 6. 추상클래스
  - 미완성 설계도 -> 미완성 메서드
  - 인스턴스를 생성할 수 없다
  - 공통 부분을 뽑아내어 조상클래스를 만드는 것
  - 반드시 구현하라는 오버라이딩을 강제한다
 
# 7. 인터페이스
  - 추상클래스의 일종
  - 모든 멤버변수는 public static final,  모든 메서드는 public abstract 모두 생략 가능함
  - 인터페이스끼리는 다중상속 가능 interface Fightable extends Moveable, Attackable{}
  - 인터페이스는 인스턴스 생성하지 못한다
  - able 등의 이름이 많다(기능) 메서드 제공한다는 개념이 강하다
  - 인터페이스를 구현할때는 public으로 구현해야한다 (public static이 생략되어있기 떄문에 더 좁아질수 없다)
  - Fightable f = new Fighter(); //구현한 클래스에 타입으로 인터페이스의 참조변수 생성 가능
  - Bunker, Barrack, Factory, Academy는 Building  클래스를 상속 받아야한다
   -> 하지만 옮길수 있는 건물은 Factory와  Barrack뿐 -> 클래스에 또 적자니 중복, Building에 넣자니 공통 기능이 되버림 -> Liftable 인터페이스를 작성하여 구현하도록 한다
   - A 클래스에서 B클래스 바로 호출 -> B 클래스 문제 생김 -> A클래스 바꿔야함
   - A 클래스-> I -> B클래스 호출  --> B클래스의 문제가 생겨 바꿔야함 -> C클래스에서 I 구현 -> A클래스 변경 필요 없음
   - interface1 패키지 참고!!!!

# 7장결론 : 다형성과 인터페이스 이론을 통해 표준화하여 기능을 제공할 수 있다. 인터페이스의 참조변수만 호출한다(캡슐화? 이후 진행은 모름) -> 사용자는 인터페이스 이후에 뭘쓰든지 기능만 잘되면 됨