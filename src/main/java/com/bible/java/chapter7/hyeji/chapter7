Chapter7

1. 상속
 #정의 : 객체의 변수와 메소드를 다른 객체가 물려 받을 수 있는 기능
   		 이미 정의되어 있는 속성을 활용하여 새로운 객체를 효율적으로 생성 가능
 #상속의 사용하는 이유
   - 객체를 자신이 만들지 않아서 소스를 변경할 수 없을 경우
   - 변경할 수 있다고 해도, 원소스 사용자가 소스 업데이트 시 나의 변경부분이 사라진다.
   - 객체가 다양한 곳에서 활용되고 있는데, 메소드 추가 시 다른곳에서 불필요한 영향을 받을 수도 있으므로.
 #상속의 장점
  - 코드 중복 제거와 재활용성의 증가
  - 유지보수의 편의성
  - 코드 가독성의 증대  
 #상속 문법  : class SubCalss extends SuperClass{ }
  -  SuperClass
     상속을 해주는 부모 클래스
     상속을 하기 위해서는 반드시 SuperClass가 SubClass보다 먼저 생성되어 있어야 함
  - SubClass
     상속을 받는 자식 클래스.
     부모클래스의 모든 멤버변수와 멤버 메소드를 상속받고, 신규 변수/메소드를 추가하여 사용 가능하다
 # Object 클래스
  - java.lang.Object 패키지에 포함되어 있다.
  - Object 클래스는 모든 자바의  최상위 클래스이다. 
  - package import와 extends Object를 하지 않아도 자동 상속되어 있다.
  - 별도의 상속이 없더라도 컴파일러가 자동으로 Object클래스를 상속한다.

2. 오버라이딩
 #정의 : 상속관계에 있는 자식 클래스가 부모클래스의 메소드를 호출하여 그대로 사용하지 않고, 
		 기능을 변경하여 자식클래스에 재 정의 후 사용할때를 오버라이딩이라 한다.
	     이때, 자식클래스에는 메소드의 이름, 리턴타입, 매개변수의 타입/갯수/순서 모두 부모클래스와 똑같은 메소드가 생성된다. 
		 오버라이딩이 되면 부모클래스 메소드는 은닉되고 서브클래스의 메소드가 사용된다.
 #메소드 오버라이딩의 조건 (제약사항)
  - 부모와 자식 메소드의 데이터 리턴 타입이 같아야 한다. (void는 void끼리, int는 int...)
  - 부모와 자식 메소드의 이름이 같아야 한다.  
  - 부모와 자식 메소드의 매개변수의 타입과 갯수, 순서가 같아야 한다.
  - 자식의 접근지정자(public...)는 부모의 접근지정자보다 범위가 줄어들수 없다.
 #레퍼런스 super 
  - 메소드 오버라이딩 후, 자식클래스에서 부모클래스의 은닉된 원래 메소드를 호출하고자 할때는 super.메소드명() 으로 은닉된 메소드 호출이 가능하다.
  - 상속관계에서 생성자는 상속이 불가능 하다. (상속되지 않는 유일한 멤버메소드)
  - 서브클래스 객체 생성시 슈퍼클래스의 생성자를 자동으로 호출하여 사용한다.
  - 상속관계에서 서브클래스의 생성자는 반드시 슈퍼클래스의 디폴트 생성자만 호출 하도록 설계 되어 있다.
  - 그렇기 때문에, 부모클래스가 오버로딩생성자를 사용하고 디폴트 생성자가 없을 경우 컴파일 에러(상속관계 에러)가 발생 한다.
  ------> 상속관계 에러 해결법
		 - 부모클래스에 디폴트생성자를 강제로 입력한다. 
		 - 부모의 오버로딩된 생성자를 자식클래스에서 호출하여 사용한다 : super
  ※ super( )생성자 호출은 반드시 첫줄에 적어야 한다
 #super를 사용한 부모클래스 오버로딩 생성자 호출
  - 부모클래스는 오버로딩 생성자 사용(디폴트 생성자 없음)
  - 자식 클래스의 기본 생성자에 부모 클래스 오버로딩 생성자 호출[출처] Java 22. 상속 (2) 생성자의 상속과 super|작성자 VANCO
 ※ 간편하게 오버라이딩 생성하기 :  alt + shift + s => overridding 선택하여 생성 가능하다.
​ # 상속관계에서의 생성자 특징 
  - 상속관계에서 생성자는 상속이 되지 않는다. (상속되지 않는 유일한 멤버메소드!)
  - 자식클래스에서 객체(인스턴스)를 생성하면 부모클래스의 디폴트 생성자를 자동으로 호출하도록 설계되어 있다. 
  - 그렇기 때문에 부모클래스에 디폴트 생성자 없이 오버로딩 생성자만 있으면 상속 받은 자식 클래스는 실행이 안된다.
  - 그러나 오버로딩 생성자 없이 디폴트 생성자도 없다면 실행이 가능하다. (컴파일러가 디폴트 생성자를 자동으로 생성 하므로) 
​ #부모클래스(슈퍼클래스)에 디폴트 생성자가 없고 오버로딩 생성자만 있을때는
      a. 부모클래스에 디폴트 생성자를 만들어 주거나
      b. super(); 로 오버로딩 생성자를 강제로 불러와 활성화 시킬 수 있다.
         ex) super(10, 20);  => 반드시 서브클래스 생성자의 첫줄에 적는다.
 #오버로딩 VS 오버라이딩  
  @ 메소드 오버로딩(overriding)
  - 동일한 클래스 또는 상속관계에서 동일한 이름의 메소드를 사용할때 
  - 동일한 이름의 메소드를 여러개 정의
  - 메소드 이름 동일, 전달인자의 타입이나 개수가 다르다.
  - 리턴타입 영향 : 없음
  - 접근지정자 영향 : 없음
   @ 메소드 오버라이딩(overriding)
  - 상속관계에서 슈퍼클래스의 메소드를 서브클래스에서 재 사용 할 때
  - 슈퍼클래스의 메소드 은닉 후 재 정의한 메소드 사용
  - 메소드 이름 동일, 전달인자의 타입과 개수도 같다.
  - 리턴타입 영향 : 있음, 동일한 형태의 리턴타입을 사용해야 한다.
  - 접근지정자 영향 : 있음, 슈퍼클래스 접근지정자보다 범위가 줄어들어서는 안된다.

4. 제어자
 # 접근제어자
  - private : 자신(this) 외에 누구도 접근할 수 없음.
  - protected : 동일 패키지내를 가진 클래스, 또는 자신을 확장(extends)한 클래스의 접근만 허용함
				(동일 패키지란, 패키지 상위 / 하위 관계와 무관하게 패키지 signature가 일치해야 함.)
  - default : 동일 패키지를 가진 클래스라면 접근을 허용함
  - public : 제한 없이 누구나 접근하여 사용할 수 있음
 # final 키워드
 - final 변수 : 상수화 시킴 > 변수 값을 변경할 수 없게 만든다
 - final 메소드 : 메서드 오버라이딩을 막는다. 
 - final 클래스 : 클래스의 상속을 막는다
 # 상속관계 접근지정자 : protected
  - 슈퍼클래스의 private 멤버는 서브클래스에서 접근이 불가하다
  - 슈퍼클래스의 default 멤버는 같은 패키지에 있는 모든 클래스에서 접근 가능하다  
  - 슈퍼클래스의 protected 멤버는 같은 패키지에 있는 모든 클래스는 물론, 다른 패키지 라도 상속받은 서브클래스에서 접근 가능
  
  
5. 다형성
 # 참조형 타입의 업캐스팅 형변환
  - 업캐스팅의 의미 : 부모클래스의 래퍼런스가 자식클래스의 인스턴스(객체)를 가리킴
  -  아래에서 위로(up) 바뀐다. 즉, 상속관계에서 자식이 부모타입으로 바뀌는 것.
  -  업캐스팅이 되면 부모로 부터 상속받은 것만 사용이 가능하기 때문에, 참조 가능한 영역이 축소 된다
  - 컴파일러가 자동으로 형변환 해준다 (묵시적 형변환, 자동형변환)
 # 참조형 타입의 다운캐스팅 형변환
  - 다운캐스팅의 의미 : 자식클래스의 레퍼런스가 부모클래스의 인스턴스를 가리킴
  - 위에서 아래로(down) 바뀐다. 즉, 상속관계에서 부모가 자식타입으로 바뀌는 것.
  - 다운캐스팅이 되면 참조 가능한 영역이 확대 된다.
  - 컴파일러가 자동으로 형변환 해주지 않기 때문에 강제로 형변환을 해주어야 한다.
  - 항상 상속관계를 확인 후 명시적 형변환을 해야 한다.
  - 먼저 업캐스팅한 레퍼런스 값을 다운캐스팅 해야 안전한 다운캐스팅이 가능하다.
 # instanceOf연산자
  - is-a 관계가 상속이면 true를 반환하고, 거짓이면 false를 리턴한다.
  - dp instanceof HandPhone : 객체 dp는 HandPhone클래스를 상속받는가?
    ----> true가 반환되면 dp는 HandPhone을 상속받음을 의미함.
 # 업캐스팅과 오버라이딩의 우선순위
  - 부모클래스와 자식클래스가 상속관계가 되면, 자식클래스에서 부모클래스를 재정의하여 사용 가능하다.
​  - 이때, main클래스에서 부모클래스에 정의된 이름의 메소드를 호출하면, 부모클래스의 원래 메소드만 사용 가능하기 때문에, 원래 부모클래스의 메소드가 호출된다.
  - 그러나, 만약, 자식클래스에서 동일한 부모클래스를 오버라이딩 해서 받아 놓았다면, 업캐스팅보다 오버라이딩의 우선순위가 높아서 자식클래스의 오버라이딩 메소드가 호출된다.
 
 
6. 추상클래스
 # 추상클래스
  - 클래스의 다형성을 구현하기 위하여 추상클래스를 사용한다.
  - 클래스 생성 시 앞에 abstract를 붙여서 선언하며, 객체를 생성할 수 없다.​
  - 추상 클래스는 추상메소드가 아닌 다른 메소드가 존재할 수도 있다. 그러나 실질적 메소드는 추상클래스를 상속받는 서브클래스에서 구현하게 된다.
  - 추상클래스를 상속받은 클래스는 오버라이딩을 통해 추상메서드를 반드시 사용해야 하므로 사용에 강제성을 부여한다. (서브클래스에서 미사용시 컴파일 에러 발생)
 # 추상메소드
  - 메소드 생성시 리턴타입 앞에 abstract를 붙여서 선언한다.
  - 메소드의 샐행을 담당하는 몸체부분인 { }을 생성할 수 없고 메소드 선언만 존재한다.
  - 추상메소드는 추상클래스 안에서 정의해야 한다.
  - 추상메소드는 반드시 오버라이딩 해서 사용해야 한다.
 # 추상클래스를 사용하는 이유
  - 여러개의 클래스에서 공통적으로 사용되는 변수, 상수, 메소드(추상메소드)를 공통적으로 구현하여 코드의 낭비를 막는다.

7. 인터페이스
 # 인터페이스란?
  - 다중상속의 도구로서, class 대신 interface를 선언하여 정의한다. 클래스와는 다른 인터페이스라는 별개의 의미와 기능이 있다.
  - 인터페이스 구현시에는 '클래스명 implements 인터페이스명'으로 구현하며, 어떤 객체가 특정한 인터페이스를 사용한다면, 그 객체는 반드시 인터페이스의 메소드들을 구현해야 한다.
 # 인터페이스의 특징
  - 인터페이스는 다중 상속의 도구로서의 역할을 한다.
  - 인터페이스에서는 상수와 추상메소드만 사용이 가능하다.
 # 추상메소드의 사용
  - 추상메소드 구현시 abstract 키워드를 사용하지 않아도 자동으로 인식한다.
  - 인터페이스 내에서 추상메소드 구현시 접근지정자는 모두 public을 써야 하며, 생략시 public으로 인식한다.
      ---->   추상메소드 구현시 리턴타입과 메소드명만 적어서 사용이 가능하다(추상으로 인식)
 # 상수의 사용
  - 상수는 반드시 static final 형태로 사용된다.
  - static, final을 사용하지 않아도 모두 static final로 인식한다.
  - 서브클래스에서 추상메소드를 오버라이딩 하여 구현한다.
  - ★★★ 다중상속이 가능하다★★★
 # 추상클래스 VS 인터페이스
  @ 공통점
  - 추상메소드를 포함하기 때문에 객체를 생성할 수 없다.
  - 서브클래스를 사용하여 해당 대상이 가지고 있는 추상 메소드를 필수적으로 구현 해야 한다(오버라이딩)
  - 업캐스팅이 가능하다
  @ 차이점
   - 추상클래스
     . 클래스이다 => abstract class선언 한다.
     . 일반메소드, 추상메소드 모드 사용가능하다.
     . 확장의 개념으로 사용한다 (extends)
     . 단일상속만 가능하다.
     . 변수, 상수 모두 사용가능
   - 인터페이스
     .인터페이스이다(클래스가 아니다) => interface로 선언한다.
     .추상메소드만 사용 가능하다. (public abstract는 디폴트값)
     .구현의 개념으로 사용한다 (implements)
     .다중상속이 가능하다.
     .상수만 사용가능 (static final이 디폴트값)
     
8. 내부클래스
 # 내부클래스(Inner class)
  - 클래스 내부에 클래스를 선언하여 외부 클래스의 필드 접근에 용이하기 위함.
  - 내부클래스의 필드를 사용하기 위해서는 외부클래스에서 내부클래스를 객체화 해야한다.
 # 사용방법
  - 외부클래스명 객체명 = new 외부클래스 생성자();
  - 외부클래스명.내부클래스명 객체명 = 외부클래스객체명.new 내부클래스생성자();
 # 내부 클래스를 사용하는 이유
  - 캡슐화 : A클래스에서 b라는 작업이 자주 쓰이고, 이 작업은 B클래스를 만들어야 쉽게 관리할 수 있음.
			하지만 다른 클래스에서 b작업이 필요없거나, B클래스를 외부에 노출시키고 싶지 않을 때 사용한다.
  - 내부클래스는 GUI (Graphic User Interface)개발시 많이 사용됨.
  - 예를 들어 a라는 버튼과 b라는 버튼이 있다고하자. 두 버튼의 기능이 서로 다르다면 클래스를 별도로 만드는 것보다 내부클래스로 만드는 것이 적합하다
 # 익명클래스(Anonymous Inner Class)
  - 이름이 없는 클래스 (일회성으로 사용하기 위함)