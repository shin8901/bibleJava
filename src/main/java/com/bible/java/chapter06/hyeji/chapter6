Ch6.객체지향 프로그래밍1

1. 객체지향언어
 - 코드의 재사용성이 높음
 - 코드의 관리가 용이(유지보수)
 - 중복된 코드 제거를 통한 신뢰성이 높은 프로그래밍 가능
 
 
 2. 클래스와 객체
  2.1 클래스와 객체의 정의와 용도
  - 클래스는 객체(실제로 존재하는 것 ex:사물, 개념, 논리...)를 생성하는데 사용
  - 객체는 서로 독립적 : 어느한 객체의 변화가 다른 객체에 영향을 주지 않음
  
  2.2 객체와 인스턴스
  - 객체는 인스턴스를 포함하는 일반적인 의미
  - 인스턴스화 : 객체를 만드는 과정
  - 인스턴스 : 클래스로부터 만들어진 객체
  - 클래스 > 인스턴스화 > 인스턴스(객체)
  
  2.3 객체의 구성요소 - 속성과 기능
  - 속성: 멤버변수 (ex:크기, 높이, 길이, 색상 ...)
  - 기능 : 메서드 (ex: 켜기, 끄기, 변경하기...)
  
  2.4 인스턴스의 생성과 사용
  - Tv t; //Tv클래스타입의 참조변수 t를 선언 
     ------ 메모리 공간 생성. 다만 인스턴스가 생성되지 않았으므로 아무것도 할 수 없는 상태
    t = new Tv(); //Tv인스턴스를 생성한후, 생성된 인스턴스의 주소를 t에저장
     ------ new에 의해 인스턴스가 메모리의 빈공간에 생성. 이때 멤버변수는 각 자료형에 해당하는 값으로 초기화 
             -> 대입연산자에 의해 객체의 주소값이 t에 저장
  - 인스턴스는 참조변수를 통해서만 다룰수 있고, 참조변수의 타입은 인스턴스 타입과 일치해야함
  - 참조변수에는 하나의값(주소)만 저장. 따라서 둘이상의 참조변수가 하나의 인스턴스를 가르키는 것은 가능 / 하나의 참조변수가 여러개의 인스턴스를 가르키는 것은 불가능
  
  2.5 객체배열
  
  2.6 클래스의 또 다른 정의
  - 변수 : 하나의 데이터를 저장할 수 있는 공간
  - 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
  - 구조체 : 서로 관련된 여러 데이터를 종류에 관게없이 하나의 집합으로 저장할 수 있는 공간
  - 클래스 : 데이터와 함수의 결합(구조체 + 함수)

 
 
 3. 변수와 메서드
  3.1 선언위치에 따른 변수의 종류
  - 변수선언 위치가 변수의 종류와 범위를 결정
  - 클래스 영역의 인스턴스변수, 클래스변수(static변수, 공유변수) = 멤버변수
  - 메서드 영역의 변수 = 지역변수
  - 클래스변수 : 클래스가 메모리에 올라갈때 생성-> 인스턴스를 생성하지 않고 언제라도 바로 사용가능 / 공통된 저장공간을 공유 -> 전역변수의 성격
  - 인스턴스변수 : 인스턴스가 생성될때마다 생성 / 독립적인 공간을 가지므로 서로 다른 값을 가짐 / 참조변수가 없을 때 gc에 의해 자동 제거됨
  - 지역변수 : 변수 선언문이 수행되었을 때 / 메서드 내, {}블럭 내에서만 사용가능 -> 메서드, {}블럭이 종료되면 소멸
  
  3.2 클래스변수와 인스턴스변수
  - 인스턴스변수는 변경이 가능한 속성값을 주로 사용 / 인스턴스가 생성될때마다 생성되므로 각기 다른값
  - 클래스변수는 공통의 속성값을 주로 사용 / 모든인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값
  
  3.3 메서드
  - 작업을 수행하기 위한 명령문의 집합
  - 하나의 메서드는 한 가지 기능만 수행하도록 작성하는 것이 좋음
  
  3.4 메서드의 선언과 구현
  
  3.5 메서드의 호출
  -같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만 static메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다.
  
  3.6 return 문
  - 메서드가 정상적으로 종료되는 경우
  - 메서드 블록 {} 내에 있는 모든 문장들을 수행했을 때
  - 메서드 블록 {} 내에 있는 문장을 수행 중 return문을 만났을 때
  - 반환 값이 없는 경우 : return;
  - 반환 값이 있는 경우 : return 반환 값;

  3.7 JVM의 메모리 구조
  - 전체적인 흐름
    1. 프로그램이 실행되면 JVM은 운영체제로 부터 메모리를 할당받음.
    2. JAVAC가 .java파일을 .class파일로 변환
    3. 클래스로더가 class파일들을 JVM으로 로딩
    4. 로딩된 class파일들은 Execution 엔진을 통해 기계어로 변경하여 실행
    5. Runtime Data Area에 바이트코드 배치
  - call stack의 특징  
    1. call stack은 메서드의 작업에 필요한 메모리 공간을 제공
    2. 메서드가 호출 -> call stack에 호출된 메서드를 위한 메모리가 할당 (이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용)
       ->메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워짐
    3. 각 메서드를 위한 메모리상의 작업공간은 서로 구별
    4. 첫 번째로 호출된 메서드의 작업공간이 call stack의 맨 밑에 마련됨. 
    첫 번째 메서드 수행중에 다른 메서드를 호출 -> 첫 번째 메서드의 바로 위에 두 번째로 호출된 메서드를 위한 공간 생성됨.
    이 때, 첫 번째 메서드는 수행을 멈추고, 두 번째 메서드가 수행되기 시작. 
    두 번째로 호출된 메서드가 수행을 마치게 되면, 두 번째 메서드를 위해 제공되었던 call stack의 메모리공간이 반환되고 첫 번째 메서드는 멈췄던 작업을 다시 수행함. 
    첫 번째 메서드가 수행을 마치면, 역시 제공되었던 메모리 공간이 call stack에서 제거되며 call stack은 완전히 비워짐.
    ---> 요약 : call stack의 제일 상위에 있는 메서드가 현재 실행 중인 메서드, 나머지는 대기상태에 있음
  -JVM 동작원리 참고 블로그
   https://blog.naver.com/shb1833/221742451974
   
  3.8 기본형 매개변수와 참조형 매개변수
  - 자바에서는 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨줌. 
  - 매개변수의 타입이 기본형(Primitive type)일 때는 기본형 값이 복사, 참조형(Reference type)이면 인스턴스의 주소가 복사.
  - 메서드의 매개변수를 기본형으로 선언하면 단순히 저장된 값만 얻지만, 참조형으로 선언하면 값이 저장된 곳의 주소를 알 수 있기 때문에 값을 읽어 오는 것은 물론 값을 변경하는 것도 가능.
		기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.(read only)
		참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.(read & write)
  3.9 참조형 반환타입
  
  3.10 재귀호출
  
  3.11 클래스메서드와 인스턴스 메서드
  
  3.12 클래스 멤버와 인스턴스 멤버간의 참조와 호출
  
  
  
 4. 오버로딩
  4.1 오버로딩이란
  - 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것

  4.2 오버로딩의 조건
  - 메서드 이름이 같아야 함
  - 매개변수의 개수 또는 타입이 달라야 함.
  - 매개변수는 같고 리턴타입이 다른 경우는 오버로딩이 성립되지 않음 (리턴 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못함.)

  4.3 오버로딩의 예
  
  4.4 오버로딩의 장점
  - 메서드의 이름만으로도 같은 기능을 할 것이라고 예상가능
  - 메서드의 이름을 절약
  
  4.5 가변인자와 오버로딩
  - 가변인자: 필요에 따라 매개변수(인수)를 가변적으로 조정
  - 기존에는 메서드의 매개변수를 고정적으로 지정해야 했지만 JDK1.5부터는 동적으로 매개변수의 개수를 지정 가능하게 바뀜
  - 기존 방식으로 여러 인자를 나열 (ex: public String methodName(String str1, String str2, String str3){ /*내용 생략*/ })
  - 가변인자를 사용 (ex: public String methodName(String... str) { /* 내용 생략 */ })
  - 가변인수의 대표적인 예는 PrintStream의 printf()와 MessageFormat의 format()
	PrintStream 클래스  의 printf 메서드 
		public PrintStream printf(String format, Object... args)
	String 클래스  의 format 메서드
		public static String format(String format, Object... args) 
  - 메서드 정의시 가변인자는 제일 마지막에 정의 해야함. 

  
  
5. 생성자
 5.1 생성자란?
 - 생성자의 이름 = 클래스 이름
 - 생성자는 리턴값이 없음
 - 생성자는 단순히 인스턴스 변수들의 초기화에 사용
 - new에 의해 인스턴스 생성 -> 생성자가 호출되어 수행 -> 생성된 인스턴스의 주소가 반환되어 참조변수에 저장
 - 상단의 2번 인스턴스 생성에서 사용했던 클래스이름()이 생성자임
 
 5.2 기본생성자
 - 클래스 내에 생성자가 하나도 없을 경우에만 자동으로 생성
 
 5.3 매개변수가 있는 생성자
 - 매개변수가 있는 생성자를 사용하면 인스턴스를 생성하는 동시에 원하는 값으로 초기화 함.
 - 생성자 오버로딩: 하나의 클래스가 여러개의 생성자를 가질 수 있음.
 
 5.4 생성자에서 다른 생성자 호출하기 - this(), this
 - 생성자의 이름으로 클래스이름 대신 this를 사용
 - 생성자에서 다른 생성자를 호출할때 반드시 첫줄에서만 호출이 가능
 - this : 인스턴스 자신을 가리키는 참조변수. 인스턴스 주소가 저장되어 있음.
 		  모든 인스턴스 메서드에 지역변수로 숨겨진채로 존재
 - this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할때 사용
 
 5.5 생성자를 이용한 인스턴스의 복사
 - 어떤 인스턴스의 상태를 알지 못해도 똑같은 상태의 인스턴스를 추가로 생성할 수 있음
 
 
 
 
 
6. 변수의 초기화
 6.1 변수의 초기화
 - 변수를 선언하고 처음으로 값을 저장하는 것
 - 지역변수는 사용하기전에 반드시 초기화 해야함
 
 6.2 명시적 초기화
 - 선언과 동시에 초기화 하는 것
 
 6.3 초기화 블럭
 - 복잡한 초기화에 사용
 - 클래스 초기화 블럭 : 클래스가 메모리에 로딩될때 한번만
 - 인스턴스 초기화 블럭 : 인스턴스를 생성할때마다 (힙영역)
 - 생성자보다 인스턴스 초기화블럭이 먼저 수행됨
 - 코드의 중복을 제거할 수 있음 -> 재사용성 높아지고 오류 적어짐
 
 6.4 멤버변수의 초기화 시기와 순서
 - 클래스 -> 인스턴스 -> 생성자
 - 클래스변수의 초기화 시점 : 클래스가 처음 로딩될 때 단 한번 초기화
 - 인스턴스변수의 초기화 시점 : 인스턴스가 생성될때마다 인스턴스별로 초기화
 - 클래스 멤버변수가 메모리(class area)에 생성 -> 멤버변수에 기본값 저장 -> 명시적 초기화 -> 클래스 초기화 블럭 
   -> 인스턴스 멤버변수가 메모리(heap)에 생성 -> 멤버변수에 기본값 저장 -> 명시적 초기화 -> 인스턴스 초기화블럭 -> 생성자 
  
  