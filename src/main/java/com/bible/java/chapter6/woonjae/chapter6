#chaper6

객체 지향
	기본이론 : 상속, 캡슐화, 추상화

객체지향 특
	1. 코드 재사용성 높
	2. 코드 관리 용이
	3. 신뢰성 높은 프로그래밍 가능
	
		재사용성
			-> 기존 코드 이용하여 쉽게 작성가능
		코드 관리 용이
		 	-> 코드간 관계를 이용해서 적은 노력으로 코드 변경 가능.
		 신뢰성 높은 프로그래밍
		 	-> 제어자, 메서드등을 이용해서 데이터 보호, 올바른 값을 유지하도록 제어 가능.
		 		코드의 중복을 제거해서, 코드의 불일치로 인한 오동작을 방지할 수 있다.
		 
	 
클래스 와 객체
	클래스 ? : 객체를 정의 , 설계해놓은 것. 생성하는데 사용
	객체(인스턴스) : 클래스를 인스턴스화 한 것.
	
	클래스  -------------인스턴스화----------> 객체
	
	
	객체 구성요소
		속성 -> 변수, 특성, 필드, 상태..
		기능 -> 메소드 , 행위, 펑션(기능) ...
		
	객체의 생성,사용
	new TV();
	
	
		변수
			클래스 변수 - 클래스 단위에서 공유
			멤버 변수 - 객체 단위에서 공유
			지역 변수 - {} 안에서 공유
		
		메소드
			권고 :
				하나의 메서드는 하나의 기능만
				반복적인 수행이 되어야하는 여러문장을 하나의 메소드로
				관련된 여러문장을 하나의 메소드로
		
		***************************************************	*
		메소드의 내부코드를 몰라도									*
		 																*
			메소드가 호출할때 어떤 값을 필요로 하는지				*
			메소드가 어떤값을 반환하는지를 알면					*
																		*
		프로그램을 작성 할 수 있다									*
		***************************************************	*
		
		기본적인 신텍스
			
			리턴타입 메소드명(파라미터){
			
				//do Something
				
				return  리턴값;
			}
			
		메서드가 종료되는 경우
			{ } 의 끝을 만났을때
			{ } 안 return 을 만난경우
			
			리턴타입이 명시된 경우, 분기되는 모든 경우에 return 이 있어야함 .
		
		JVM 메모리~~~~~~~
		method area -> 실행중에 어떤 클래스가 사용되면, jvm이 해당 클래스정보를 분석 , 이 영역에 저장.
		heap area -> 인스턴스가 생성되는 공간, 프로그램 실행중 생성되는 인스턴스는 여기 담김.
		호출 스택 -> 
			메서드 작업에 필요한 공간 제공.
			지역변수들 의 중간결과 등을 저장.
			호출 메소드의 순서를 저장.
			
		재귀 vs 반복
			재귀호출 : 재귀호출하면서 호출한 메소드의 독립된 스택을 할당받음.
			반복 :  현재 호출스택 내에서 처리.
		
		
		*****************오 버 로 딩***************
		
		prlntln 
				-> 호요잇 아무거나 쌉가능 
				-> 이유 오 바 로 딩
				-> 각기 다른 메소드명으로 선언되지 아니하고, 동일명으로 처리 가능.
					개발 편의성 부여.
					
					
		생성자
		 *	클래스에 생성자가 없는경우 기본 생성자를 컴파일러가 만듬
		 *  명시적으로 선언되면, 기본 생성자 사라짐.
		 
		 초기화 블럭  - 호오옹 
		 	1111111111111111
			생성전
			22222222222222
		 
		  
		
			
		
		
		
					
			
	 