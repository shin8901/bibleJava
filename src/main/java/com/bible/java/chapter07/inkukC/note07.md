# 1.상속
 - 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것.
 - 상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 초드의 추가 및 변경이 용이.
 - 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여.
 - 상속해주는 클래스 : 조상 클래스, 상속 받는 클래스 : 자손 클래스
 - 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
 - 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스가 생성된다.
 - 클래스안에 다른 클래스 참조변수 선언 : 포함관계 - 상속이외의 클래스 재사용하는 방법
 - 원은 점이다 - 상속으로 처리, 원은 점을 가지고 있다 - 포함관계로 처리
 - 자바는 단일 상속만 가능 - 다중상속은 클래스간의 관계가 매우 복잡해지고 상속받은 멤버간의 이름이 같은 경우 구별할 수 없다.
 
# 2.오버라이딩
 - 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것.
 - 이름이 같아야하고, 매개변수가 같아야하고, 반환타입이 같아야한다. 접근제어자와 예외는 조상의 범위보다 적게 변경 가능.
 - static 메서드는 같은 이름으로 사용 가능하나 이것은 오버라이딩이 아니다. static멤버들은 자신들이 정의된 클래스에 묶여있다고 생각하자.
 - 오버로딩은 기존에 없는 새로운 메서드를 정의(NEW), 오버라이딩은 상속받은 메서드의 내용을 변경(Change, modify)
 - super를 사용하여 상속받은 클래스 접근 가능.
 - 모든 클래스의 생성자 첫줄엔 this() or super()을 호출해야함. 없다면 자동적으로 컴파일이 삽입.
 - 인스턴스를 생성할땐 클래스의 선택과 선택한 클래스의 생성자 선택이 중요.
 
# 3.패키지와 임포트

# 4.제어자
 - static - 멤버변수, 메서드, 초기화 블럭에 사용
 - final - 클래스, 메서드, 멤버변수, 지역변수. 변수에 사용되면 값을 변경할 수 없는 상수가되며, 메서드에 사용하면 오버라이딩을 할 수 없게 되고 클래스에  사용되면 자신을 확장하는 자손클래스의 정의를 못함. fianl 매개면수인 경우 생성자를 통해 초기화가 가능하다 -> 인스턴스 별로 final 변수값을 다르게 가져갈수 있다.
 - 접근 제어자 : public > protected > default > private
  -> 사용하는 이유 : 외부로부터 데이터 보호, 외부에는 불필요한, 내부적으로만 사용되는 부븐을 감추기 위해. public 메소드가 존재할때 수정되는 상황이 오면 많은곳에서 사용을 하고 있기때문에 테스트 범위가 넓어진다.
  -> 생성자에 private를 넣어 인스턴스 생성을 제한할 수 있다. 이런 경우 인스턴스 생성을 위한 메서드를 제공하는데 public static으로 사용한다. 이렇게 하면 인스턴스 갯수 제한이 가능하다. 또한, 생성자 private는 조상클래스가 될수가 없기때문에 final을 붙여 보면 알수있게 하는게 좋다.
  
# 5.다형성
 - 한타입의 참조변수로 여러타입의 객체를 참조할수 있는것. 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조 할 수 있다. 단, 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.
 - 자손 -> 조상 : 형변환 생략 가능, 조상 -> 자손 : 형변환 생략 불가
 - 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행 될 수 있으나, 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용하지 않는다. 
 - instanceOf연산자를 통해 참조변수가 참조하고 있는 인스턴스를 알 수 있다. true 인 경우 형변환이 가능.
 - 조상클래스와 자손클래스에 동일한변수와 메소드가 있는경우(오버로딩) -> 조상타입의 참조변수로 자손 인스턴스를 참조하는 경우 = 조상멤버면수, 자손오버로딩메소드
 												   -> 자손타입의 참조변수로 자손 인스턴스를 참조하는 경우 = 자손멤버변수, 자손오버로딩메소드
 - 동일한변수와 메소드가 없는 경우는 있는 변수와 메소드를 사용
 
# 6.추상클래스
 - 미완성메소드 포함된 클래스, 상속을 통해서 자손클래스에 의해서 완성.
 - 조상 클래스에서는 선언부만 작성 + 주석을 덧붙여 수행 목적을 적자.
 - 추상화 : 클래스간의 공통점으 찾아내서 공통의 조상을 만드는 작업, 구체화 : 상속을 통해 클래스를 구현, 확장하는 작업
 
# 7.인터페이스
 - 추상클래스보다 더 추상화가 높음. 추상메서드와 상수만 가질수 있음.
 - 모든 멤버변수는 public static final, 생략가능. 메서드는 public abstract, 생략가능하나  static 메서드와 디폴트 메서드는 예외(JDK 1.8)
 - 인터페이스 메소드의 리턴값이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는것을 의미.
 - 개발시간을 단축 : 작성된 인터페이스로 내용없이 선언부만 알고 다른개발자가 개발 가능. 인터페이스를 구현하는 클래스가 작성될때까지 기다리지 않고 동시 개발이 가능하다.
 - 표준화 가능 : 기본 틀을 인터페이스로 작성 후 다른 개발자에게 인터페이스 구현하도록 하여 일관되고 정형화된 프로그램 개발 가능
 - 서로 관계 없는 클래스 관계를 맺어줌 : 상속과 같은 조상클래스가 없어도 인터페이스를 공통적으로 구현하면 관계가 맺어짐
 - 독집적인 프로그래밍 : 클래스의 선언과 구현을 분리할수 있기 때문에 독립적인 코딩 가능.
 
# 8.내부클래스
 - 내부클래스에서 외부 클래스의 멤버들을 쉽게 접근 가능, 코드의 복잡성을 줄임